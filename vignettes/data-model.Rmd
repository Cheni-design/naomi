---
title: "Naomi data model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Naomi data model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE, message = FALSE}
devtools::load_all()
library(tidyverse)
library(datamodelr)
library(sf)
```

## Load datasets

```{r load_datasets}
#' areas
area_meta <- readRDS(system.file("extdata/areas/area_meta.rds", package = "naomi"))
areas <- readRDS(system.file("extdata/areas/areas.rds", package = "naomi"))
area_geom <- readRDS(system.file("extdata/areas/area_geom.rds", package = "naomi"))
area_boundaries <- readRDS(system.file("extdata/areas/area_boundaries.rds", package = "naomi"))

#' population
population_agesex <- readRDS(system.file("extdata/population/population_agesex.rds",
                                         package = "naomi"))
age_group_meta <- get_age_groups()
```

```{r create_model, include = FALSE}
dm_add_colors(
  dm_color_scheme(
    population = dm_palette(
      line_color = "#8064A2",
      header_bgcolor = "#B1A0C7",
      header_font = "#FFFFFF",
      bgcolor = "#E4DFEC"
    ),
    areas = dm_palette(
      line_color = "#C0504D",
      header_bgcolor = col2rgb("darkred") %>% {rgb(.[1], .[2], .[3], maxColorValue = 255)},
      header_font = "#FFFFFF",
      bgcolor = "#F2DCDB"
    )
  )
)

dm <- dm_from_data_frames(area_meta, areas, area_geom, area_boundaries,
                          age_group_meta, population_agesex) %>%
  dm_set_key("area_meta", c("iso3", "area_level")) %>%
  dm_set_key("areas", c("iso3", "area_id")) %>%
  dm_set_key("area_geom", c("iso3", "area_id", "type")) %>%
  dm_set_key("area_boundaries", c("iso3", "area_id")) %>%
  dm_set_key("age_group_meta", "age_group_id") %>%
  dm_set_key("population_agesex", c("iso3", "area_id", "sex", "age_group_id", "source")) %>%
  dm_add_references(
    areas$iso3 == area_meta$iso3,
    areas$area_level == area_meta$area_level,
    area_geom$iso3 == areas$iso3,
    area_geom$area_id == areas$area_id,
    area_boundaries$iso3 == areas$iso3,
    area_boundaries$area_id == areas$area_id,
    population_agesex$area_id == areas$area_id,
    population_agesex$age_group_id == age_group_meta$age_group_id
  ) %>%
  dm_set_segment(
    list("Areas" = c("area_meta", "areas", "area_geom", "area_boundaries"),
         "Population" = c("age_group_meta", "population_agesex"))
  ) %>%
  dm_set_display(
    list(
      areas = c("area_meta", "areas", "area_geom"),
      population = c("age_group_meta", "population_agesex"),
      accent6 = c("area_boundaries", "age_group_meta")
    )
  )


```

```{r create_graph, fig.width = 5, fig.height = 7, fig.align = "center"}
#' Render graph
dm_create_graph(dm, rankdir = "BT", col_attr = c("column", "type"),
                columnArrows = TRUE) %>%
  dm_render_graph()
```

## Data model questions

#### Spatial geometry format

The area dataset may need to retain both area boundaries as polygons and area centroids, or adjusted centroids for plotting area level labels or statistics. Centroids are easily calculated from the polygons, however in some cases, points used for plotting or labelling may need to be manually adjusted to avoid overlap, and desire to save these adjusted point references. For example, Zomba and Zomba City in Malawi. 

The data model above shows two approaches for capturing these data, only one of which should be retained:

* The `area_boundaries` table is in 'wide' format with a column for boundary polygons, a column for centroid points, and column for adjusted centroid points. This wide format is accepted (under protest) by R's `sf` class, but GeoJSON and ESRI .shp formats do not admit multiple geometries, so polygon and point would need to be saved as separate layers in those formats.
* The `area_geom` table is in 'long format' with an additional `type` columns specifying _boundary_, _centroid_, or _adjusted_centroid_. The type is filtered to select the desired geometry for a given plotting purpose. GeoJSON format accepts both polygon and point data in a single collection, however ESRI .shp format does not, requiring each type to be saved as a separate layer.

Our current preference is to favour the `area_geom` 'long' format and save geometry data as GeoJSON format as default. It may also be that there are suitable algorithmic solutions to offsetting points for plotting such that saving adjusted centroid points is not needed.

The figures below show example code for generating a typical plot with either boundary data format.

```{r, fig.width=7, fig.height=4, warning=FALSE}
#' Using area_geom
areas %>%
  left_join(area_boundaries) %>%
  st_as_sf %>%
  left_join(area_meta %>% select(iso3, area_level, area_level_label)) %>%
  mutate(area_level_label = area_level_label %>% fct_reorder(area_level)) %>%
  ggplot() +
  geom_sf() +
  geom_sf_label(aes(label = area_sort_order), data = . %>% st_set_geometry("center_adj")) +
  facet_wrap(~area_level_label, nrow = 1) +
  th_map() +
  ggtitle("Using area_boundaries")

#' Using area_geom
areas %>%
  left_join(area_geom) %>%
  st_as_sf %>%
  left_join(area_meta %>% select(iso3, area_level, area_level_label)) %>%
  mutate(area_level_label = area_level_label %>% fct_reorder(area_level)) %>%
  ggplot() +
  geom_sf(data = . %>% filter(type == "boundary")) +
  geom_sf_label(aes(label = area_sort_order), data = . %>% filter(type == "center_adj")) +
  facet_wrap(~area_level_label, nrow = 1) +
  th_map() +
  ggtitle("Using area_geom")
